import logging
import os
import django
from datetime import datetime, timedelta
from django.utils import timezone
from asgiref.sync import sync_to_async
from telegram import Update, KeyboardButton, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
    CallbackQueryHandler
)
token="token"


# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Django –æ–∫—Ä—É–∂–µ–Ω–∏—è
# os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
# django.setup()

# # –ò–º–ø–æ—Ä—Ç –º–æ–¥–µ–ª–µ–π –ø–æ—Å–ª–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ Django
# from main.models import Schedule, Teacher

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start. –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É."""
    keyboard = [[KeyboardButton("–ü–æ–∫–∞–∑–∞—Ç—å –º–æ–π Telegram ID")]]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.",
        reply_markup=reply_markup,
    )

async def get_id(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –µ–≥–æ Telegram ID."""
    user_id = update.effective_user.id
    
    await update.message.reply_text(
        f"–í–∞—à Telegram ID: `{user_id}`\n\n"
        "–°–∫–æ–ø–∏—Ä—É–π—Ç–µ ID –∏ –≤—Å—Ç–∞–≤—å—Ç–µ –µ–≥–æ –≤ –ø–æ–ª–µ 'Telegram ID' –≤ –≤–∞—à–µ–º –ø—Ä–æ—Ñ–∏–ª–µ –Ω–∞ —Å–∞–π—Ç–µ –ë–ú–≠.",
        parse_mode="Markdown"
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞."""
    await update.message.reply_text(
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "‚Ä¢ –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–π Telegram ID - –ø–æ–ª—É—á–∏—Ç—å –≤–∞—à ID –¥–ª—è –ø—Ä–∏–≤—è–∑–∫–∏ –∫ –ø—Ä–æ—Ñ–∏–ª—é\n"
        "‚Ä¢ –ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ - –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É"
    )

# @sync_to_async
# def get_available_schedule_dates():
#     """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞—Ç—ã —Å –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã–º–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è–º–∏ –¥–ª—è –≤—á–µ—Ä–∞, —Å–µ–≥–æ–¥–Ω—è –∏ –∑–∞–≤—Ç—Ä–∞."""
#     today = timezone.now().date()
#     yesterday = today - timedelta(days=1)
#     tomorrow = today + timedelta(days=1)
    
#     dates_to_check = [yesterday, today, tomorrow]
#     available_dates = []
    
#     for date in dates_to_check:
#         if Schedule.objects.filter(date=date, is_public=True).exists():
#             available_dates.append(date)
    
#     return available_dates

# def format_date_display(date):
#     """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–∞—Ç—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""
#     today = timezone.now().date()
    
#     if date == today:
#         return f"–°–µ–≥–æ–¥–Ω—è ({date.strftime('%d.%m.%Y')})"
#     elif date == today - timedelta(days=1):
#         return f"–í—á–µ—Ä–∞ ({date.strftime('%d.%m.%Y')})"
#     elif date == today + timedelta(days=1):
#         return f"–ó–∞–≤—Ç—Ä–∞ ({date.strftime('%d.%m.%Y')})"
#     else:
#         return date.strftime('%d.%m.%Y')

# async def show_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∞—Ç—ã —Å –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è–º–∏."""
#     available_dates = await get_available_schedule_dates()
    
#     if not available_dates:
#         await update.message.reply_text(
#             "–ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã—Ö —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–π –Ω–∞ –≤—á–µ—Ä–∞, —Å–µ–≥–æ–¥–Ω—è –∏ –∑–∞–≤—Ç—Ä–∞."
#         )
#         return
    
#     # –°–æ–∑–¥–∞–µ–º inline –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –¥–∞—Ç–∞–º–∏
#     keyboard = []
#     for date in available_dates:
#         date_text = format_date_display(date)
#         callback_data = f"schedule_{date.strftime('%Y-%m-%d')}"
#         keyboard.append([InlineKeyboardButton(date_text, callback_data=callback_data)])
    
#     reply_markup = InlineKeyboardMarkup(keyboard)
    
#     await update.message.reply_text(
#         "–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è:",
#         reply_markup=reply_markup
#     )

# @sync_to_async
# def get_teacher_by_telegram_id(telegram_id):
#     """–ü–æ–ª—É—á–∞–µ—Ç –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID."""
#     try:
#         teacher = Teacher.objects.get(user__telegram_id=str(telegram_id), is_working=True)
#         return teacher
#     except Teacher.DoesNotExist:
#         return None

# @sync_to_async
# def format_schedule_for_teacher(schedules, teacher):
#     """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è."""
#     teacher_lessons = []
    
#     for schedule in schedules:
#         for lesson in schedule.lessons.filter(teacher=teacher):
#             teacher_lessons.append((schedule, lesson))
    
#     if not teacher_lessons:
#         return None
    
#     # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –ø–∞—Ä—ã
#     teacher_lessons.sort(key=lambda x: x[0].lesson_time)
    
#     message = f"üìÖ <b>–í–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {teacher_lessons[0][0].date.strftime('%d.%m.%Y')}:</b>\n\n"
    
#     for schedule, lesson in teacher_lessons:
#         classroom = lesson.classroom or "–ù–µ —É–∫–∞–∑–∞–Ω–∞"
#         groups = ", ".join([str(group) for group in schedule.group.all()])
#         students_count = lesson.students.count()
        
#         message += f"üìö <b>–ü–∞—Ä–∞ {schedule.lesson_time}:</b>\n"
#         message += f"‚è∞ {schedule.get_lesson_time_display()}\n"
#         message += f"üè¢ –ó–¥–∞–Ω–∏–µ: {schedule.location}\n"
#         message += f"üè´ –ê—É–¥–∏—Ç–æ—Ä–∏—è: {classroom}\n"
#         message += f"üéì –£—Ä–æ–≤–µ–Ω—å: {lesson.grade}\n"
#         message += f"üë• –ì—Ä—É–ø–ø—ã: {groups}\n"
#         message += f"üë®‚Äçüéì –°—Ç—É–¥–µ–Ω—Ç—ã: {students_count}\n"
        
#         if lesson.is_extra:
#             message += f"üìù –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–Ω—è—Ç–∏–µ\n"
#         if lesson.is_quiz:
#             message += f"üìä –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π —Å—Ä–µ–∑\n"
        
#         message += "\n"
    
#     return message

# @sync_to_async
# def get_schedules_by_date(selected_date):
#     """–ü–æ–ª—É—á–∞–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É."""
#     return list(Schedule.objects.filter(date=selected_date, is_public=True).prefetch_related(
#         'group', 'lessons__teacher', 'lessons__grade', 'lessons__students', 'location'
#     ))

# async def handle_schedule_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç callback —Å –≤—ã–±–æ—Ä–æ–º –¥–∞—Ç—ã —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è."""
#     query = update.callback_query
#     await query.answer()
    
#     # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞—Ç—É –∏–∑ callback_data
#     callback_data = query.data
#     if not callback_data.startswith("schedule_"):
#         await query.edit_message_text("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.")
#         return
    
#     date_str = callback_data.replace("schedule_", "")
#     try:
#         selected_date = datetime.strptime(date_str, '%Y-%m-%d').date()
#     except ValueError:
#         await query.edit_message_text("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã.")
#         return
    
#     # –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É
#     schedules = await get_schedules_by_date(selected_date)
    
#     if not schedules:
#         await query.edit_message_text(
#             f"–ù–∞ {selected_date.strftime('%d.%m.%Y')} –Ω–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è."
#         )
#         return
    
#     # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–º
#     user_telegram_id = update.effective_user.id
#     teacher = await get_teacher_by_telegram_id(user_telegram_id)
    
#     if teacher:
#         # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è
#         teacher_schedule = await format_schedule_for_teacher(schedules, teacher)
#         if teacher_schedule:
#             message = teacher_schedule
#         else:
#             message = f"–£ –≤–∞—Å –Ω–µ—Ç –∑–∞–Ω—è—Ç–∏–π –Ω–∞ {selected_date.strftime('%d.%m.%Y')}."
#     else:
#         # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
#         message = f'–≤–Ω–µ—Å–∏—Ç–µ –≤–∞—à Telegram ID –≤ –ø—Ä–æ—Ñ–∏–ª—å –Ω–∞ —Å–∞–π—Ç–µ –ë–ú–≠\n\n'
#         message += f"–í–∞—à Telegram ID: <code>{user_telegram_id}</code>\n"
    
#     # Telegram –∏–º–µ–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è (4096 —Å–∏–º–≤–æ–ª–æ–≤)
#     if len(message) > 4000:
#         # –†–∞–∑–±–∏–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏
#         parts = []
#         current_part = ""
        
#         for line in message.split('\n'):
#             if len(current_part + line + '\n') > 4000:
#                 parts.append(current_part)
#                 current_part = line + '\n'
#             else:
#                 current_part += line + '\n'
        
#         if current_part:
#             parts.append(current_part)
        
#         # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—É—é —á–∞—Å—Ç—å –∫–∞–∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
#         await query.edit_message_text(parts[0], parse_mode="HTML")
        
#         # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —á–∞—Å—Ç–∏ –∫–∞–∫ –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
#         for part in parts[1:]:
#             await context.bot.send_message(
#                 chat_id=query.message.chat_id,
#                 text=part,
#                 parse_mode="HTML"
#             )
#     else:
#         await query.edit_message_text(message, parse_mode="HTML")

def main() -> None:
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –±–æ—Ç–∞."""
    # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ Django
    #token = settings.TELEGRAM_BOT_TOKEN
    if not token:
        logger.error("–¢–æ–∫–µ–Ω Telegram –±–æ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö!")
        return
    
    # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    application = Application.builder().token(token).build()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(MessageHandler(filters.Regex("^–ü–æ–∫–∞–∑–∞—Ç—å –º–æ–π Telegram ID$"), get_id))
    # application.add_handler(MessageHandler(filters.Regex("^–ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ$"), show_schedule))
    # application.add_handler(CallbackQueryHandler(handle_schedule_callback, pattern="^schedule_"))
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main() 
